<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Oneweeks on hello</title>
    <link>https://yhj123.github.io/hugoblog/oneweek/</link>
    <description>Recent content in Oneweeks on hello</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 27 Dec 2020 10:48:10 +0800</lastBuildDate><atom:link href="https://yhj123.github.io/hugoblog/oneweek/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>KMP、BM、KR、Sunday算法</title>
      <link>https://yhj123.github.io/hugoblog/oneweek/sunday/</link>
      <pubDate>Sun, 27 Dec 2020 10:48:10 +0800</pubDate>
      
      <guid>https://yhj123.github.io/hugoblog/oneweek/sunday/</guid>
      <description>周日笔记 KMP算法 #define _CRT_SECURE_NO_DEPRECATE #include &amp;lt;iostream&amp;gt; #include &amp;lt;string&amp;gt; using namespace std; void Violentmatch(char *p, char *s) { //s与p的长度 int sLen = strlen(s); int pLen = strlen(p); //匹配过程 int i = 0; int j = 0; while (i &amp;lt; sLen&amp;amp;&amp;amp;j &amp;lt; pLen) { if (s[i] == p[j]) { i++; j++; } else { i = i - j + 1; j = 0; } } //匹配结果不同,返回结果不同 if (j == pLen) cout &amp;lt;&amp;lt; &amp;quot;匹配成功&amp;quot; &amp;lt;&amp;lt; endl; else cout &amp;lt;&amp;lt; &amp;quot;匹配失败&amp;quot; &amp;lt;&amp;lt; endl; } int main() { char* p = &amp;quot;ABCDABD&amp;quot;; char* s = &amp;quot;BBCABCDABABCDABCDABDE&amp;quot;; Violentmatch(p, s); } </description>
    </item>
    
    <item>
      <title>map与unordered_map区别</title>
      <link>https://yhj123.github.io/hugoblog/oneweek/saturday/</link>
      <pubDate>Sun, 27 Dec 2020 00:36:28 +0800</pubDate>
      
      <guid>https://yhj123.github.io/hugoblog/oneweek/saturday/</guid>
      <description>周六笔记 </description>
    </item>
    
    <item>
      <title>动态规划</title>
      <link>https://yhj123.github.io/hugoblog/oneweek/friday/</link>
      <pubDate>Fri, 25 Dec 2020 15:35:05 +0800</pubDate>
      
      <guid>https://yhj123.github.io/hugoblog/oneweek/friday/</guid>
      <description>周五笔记:  常见动态规划类型  坐标型动态规划 序列型动态规划 划分型动态规划 区间型动态规划 背包型动态规划 最长序列型动态规划 博弈型动态规划 综合性动态规划   动态规划题型:  计数  有多少种方式走到右下角 有多少种方法选出k个数使得和为sum   求最大最小值  从左上角走到右下角路径的最大数字和 最长上升子序列长度   求存在性  取石子游戏,先手是否必胜 能不能选出k个数使得和是sum     动态规划思路:  确定状态(两个意识):  最后一步 子问题   转移方程 初始条件和边界情况 计算顺序   动态规划例题:  coin change Unique Paths Jump Game Maximum Product Subarray   Maximum Product Subarray  class Solution { public: int maxProduct(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector &amp;lt;int&amp;gt; maxF(nums), minF(nums); for (int i = 1; i &amp;lt; nums.</description>
    </item>
    
  </channel>
</rss>
